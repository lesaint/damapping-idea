/**
 * Copyright (C) 2013 Sébastien Lesaint (http://www.javatronic.fr/)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package fr.javatronic.damapping.intellij.plugin.integration.provider;

import fr.javatronic.damapping.intellij.plugin.integration.component.project.ParseAndGenerateManager;
import fr.javatronic.damapping.intellij.plugin.integration.index.AnnotedClassQualifiedNameIndex;
import fr.javatronic.damapping.intellij.plugin.integration.index.GeneratedClassQualifiedNameIndex;

import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Set;
import com.google.common.collect.Lists;

import com.intellij.openapi.diagnostic.Logger;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.psi.PsiClass;
import com.intellij.psi.PsiDirectory;
import com.intellij.psi.PsiElementFinder;
import com.intellij.psi.PsiFile;
import com.intellij.psi.PsiJavaFile;
import com.intellij.psi.PsiManager;
import com.intellij.psi.PsiPackage;
import com.intellij.psi.search.GlobalSearchScope;
import com.intellij.util.Processor;
import com.intellij.util.indexing.FileBasedIndex;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

/**
 * DAMappingElementFinder - IDEA extension responsible for making interfaces generated by the DAMapping annotation
 * processor visible to IDEA even though the annotation processor hasn't run thus providing feedback to the user
 * that her usage of generated interfaces is valid or not.
 *
 * @author Sébastien Lesaint
 */
public class DAMappingElementFinder extends PsiElementFinder {
  private static final Logger LOGGER = Logger.getInstance(DAMappingAugmentProvider.class.getName());

  private final Project project;

  public DAMappingElementFinder(Project project) {
    this.project = project;
    LOGGER.debug("DAMappingElementFinder created");
  }

  // TODO no processing if project is dumb or plugin is not enabled on project
//  final Project project = element.getProject();
//  if (DumbService.getInstance(project).isDumb()) {
//    LOGGER.debug("Index rebuilding in progress");
//    return Collections.emptyList();
//  }

  @Nullable
  @Override
  public PsiClass findClass(@NotNull String qualifiedName,
                            final @NotNull GlobalSearchScope scope) {    // FIXME : ignore methods call if scope is
    // not project (or even a module with activated DAMapping support ?)
    PsiClass[] classes = findClasses(qualifiedName, scope);
    if (classes.length > 0) {
      return classes[0];
    }

    return null;
  }

  @NotNull
  @Override
  public PsiClass[] findClasses(@NotNull String qualifiedName, @NotNull GlobalSearchScope scope) {
    Collection<VirtualFile> virtualFiles = FileBasedIndex.getInstance().getContainingFiles(
        GeneratedClassQualifiedNameIndex.NAME, qualifiedName, scope
    );
    if (virtualFiles.isEmpty()) {
      return PsiClass.EMPTY_ARRAY;
    }

    for (VirtualFile virtualFile : virtualFiles) {
      List<PsiClass> generatedClasses = getGeneratedClasses(virtualFile, scope);
      for (PsiClass generatedClass : generatedClasses) {
        if (qualifiedName.equals(generatedClass.getQualifiedName())) {
          return new PsiClass[] { generatedClass };
        }
      }
    }
    return PsiClass.EMPTY_ARRAY;
  }

  /**
   * Retrieves the PsiClass for classes generated by DAMapping for the specific {@link VirtualFile}, if there is any,
   * and return them as a List.
   */
  @NotNull
  private List<PsiClass> getGeneratedClasses(VirtualFile virtualFile, GlobalSearchScope scope) {
    PsiFile psiFile = PsiManager.getInstance(project).findFile(virtualFile);
    if (psiFile instanceof PsiJavaFile) {
      return ParseAndGenerateManager.getInstance(project)
                                    .getGeneratedPsiClasses(((PsiJavaFile) psiFile).getClasses()[0], scope);
    }
    return Collections.emptyList();
  }

  @Nullable
  @Override
  public PsiPackage findPackage(@NotNull String qualifiedName) {
    return super.findPackage(qualifiedName); // use super method because we do not generate any new package
  }

  @NotNull
  @Override
  public PsiPackage[] getSubPackages(@NotNull PsiPackage psiPackage, @NotNull GlobalSearchScope scope) {
    return super.getSubPackages(psiPackage, scope); // use super method because we do not generate any new package
  }

  /**
   * To find all classes generated by DAMapping in a specific package, we look up classes annoted with DAMApping in that
   * specific package using the index of AnnotedClassesQualifiedNames.
   */
  @NotNull
  @Override
  public PsiClass[] getClasses(@NotNull PsiPackage psiPackage, @NotNull GlobalSearchScope scope) {
    String packageName = psiPackage.getQualifiedName();
    Collection<String> qualifiedNames = FileBasedIndex.getInstance().getAllKeys(
        AnnotedClassQualifiedNameIndex.NAME, project
    );
    List<PsiClass> res = Lists.newArrayList();
    for (String qualifiedName : qualifiedNames) {
      if (qualifiedName.startsWith(packageName)) {
        Collection<VirtualFile> virtualFiles = FileBasedIndex.getInstance()
                                                             .getContainingFiles(
                                                                 AnnotedClassQualifiedNameIndex.NAME,
                                                                 qualifiedName, scope
                                                             );
        for (VirtualFile virtualFile : virtualFiles) {
          List<PsiClass> generatedClasses = getGeneratedClasses(virtualFile, scope);
          res.addAll(generatedClasses);
        }
      }
    }
    return res.toArray(new PsiClass[res.size()]);
  }


  @NotNull
  @Override
  public Set<String> getClassNames(@NotNull PsiPackage psiPackage, @NotNull GlobalSearchScope scope) {
    return super.getClassNames(psiPackage, scope
    ); // super method uses getClasses(PsiPackage, GlobalSearchScope) in a way that suits us
  }

  @Override
  public boolean processPackageDirectories(@NotNull PsiPackage psiPackage, @NotNull GlobalSearchScope scope,
                                           @NotNull Processor<PsiDirectory> consumer) {
    return super.processPackageDirectories(psiPackage, scope, consumer
    ); // don't know what's that method for, use supermethod for now
  }

  @NotNull
  @Override
  public PsiClass[] getClasses(@Nullable String className, @NotNull PsiPackage psiPackage,
                               @NotNull GlobalSearchScope scope) {
    return super.getClasses(className, psiPackage, scope
    ); // super method uses getClasses(PsiPackage, GlobalSearchScope) in a way that suits us
  }
}
